# Esp8266WOL: Wake devices on your LAN, over the internet, using an SoC

Configure your Esp8266 as a web server, equipping it with the capability to dispatch magic packets for awakening any device within your local area network (LAN). The web server implements HTTPS for secure and private connections, bolstered by Two-Factor Authentication (2FA) through Time-Based One-Time Passwords (TOTP) to thwart potential threats seeking to rouse your devices maliciously.

![Diagram](https://github.com/CenturySturgeon/Esp8266WOL/blob/main/WOL_Diagram.svg)

### NOTES

* Even though the essential custom variables are found on the 'envVariables.h' file, on the 'wifi_utils.h' file you'll find aditional customizable variables you can modify, like the DNS server used, the NTP server to synch the time with, the time interval to check for public IP changes and more.

* The Crypto library is used to safekeep passwords as SHA-256 encrypted hashes and not in plain text. You can install this library directly from the Arduino IDE, it's the one from Rhys Weatherly, more of this in the github repo https://github.com/rweather/arduinolibs. To generate your hashes, you can use the hash256Generator.py file.

* Each user will be assigned a random, four digit pin as a password. This four digit pin will be printed to the terminal, alongside its username, after running the 'envVariablesCreator.py' script. Be sure to write them down. Also, you can manually assign the four digit pin to any of your liking, but you'll have to calculate its hash and place it inside the 'envVariables.h' file.

* On login submission, the created hash is created from a mix of the username plus the ":" character and the password (the four digit pin).

```
calculateSHA256Hash(username:password);
```

The hash generation combination can be modified on the 'routes.h' file on line 66, although I'd recommend that your hashes remain some kind of mix of the username and password.

```
String credentials = calculateSHA256Hash(username + ":" + password);
```

## Requirements

### Arduino Libraries

You'll require to install the following Arduino libraries in order for the code to work (all of them can be installed through the Arduino IDE):
```
Arduino's ESP8266WiFi (for WiFiClient and WiFiClientSecure) https://github.com/esp8266/Arduino/tree/master/libraries/ESP8266WiFi

Arduino's Wifi library, more at https://www.arduino.cc/reference/en/libraries/wifi/

Arduino's ESP8266WebServer and ESP8266WebServerSecure https://github.com/esp8266/Arduino/tree/master/libraries/ESP8266WebServer

Arduino's ESP8266mDNS https://github.com/esp8266/Arduino/blob/master/libraries/ESP8266mDNS

NTPClient library by Fabrice Weinberg https://www.arduino.cc/reference/en/libraries/ntpclient/

TOTP library by Luca Dentella https://www.arduino.cc/reference/en/libraries/totp-library/

Crypto library by Rhys Weatherly https://www.arduino.cc/reference/en/libraries/crypto/

WOL library by a7md0 https://github.com/a7md0/WakeOnLan.

ArduinoJson by Benoit Blanchon https://www.arduino.cc/reference/en/libraries/arduinojson/
```
### .Env File
To enable the functionality of this code, it's essential to generate an additional file named "envVariables.h". This file is automatically generated through the execution of the envVariablesCreator.py script. No adjustments are needed in the Python script itself; instead, you'll require an .env file to store all pertinent information. Here's a glimpse of the structure of this .env file:

```
# Set your network credentials:
WIFI_NAME=YOUR_WIFI_NETWORK_NAME
WIFI_PASSWORD=YOUR_WIFI_PASSWORD

# The static IP for the Esp8266 is up to your choice.
ESP8266_STATIC_IP=192.168.7.77

# These two you get from your router (with ipconfig in the terminal for example).
ROUTER_LOCAL_GATEWAY=192.168.8.88
SUBNET=255.255.255.0

# The url of the site from which the Esp8266 will poll its public IP.
IP_SITE_URL=api.ipify.org

# Set your users sessions (you can add or delete).
# User sessions should follow the structure {username, timeout span in seconds, TOTP label and issuer}.
USER_SESSIONS=[{"username": "user1", "timeout": 60, "totp_label": "MyAccount", "issuer": "Esp8266"}, {"username": "user2", "timeout": 60, "totp_label": "MyAccount", "issuer": "Esp8266"}, {"username": "user3", "timeout": 120, "totp_label": "MyAccount", "issuer": "Esp8266"}]

# Your telegram bot API token and user id:
TELEGRAM_BOT_TOKEN=XXXXXXXXXX:XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
TELEGRAM_CHAT_ID=XXXXXXXXXX

# Telegram's api url; the Esp8266 sends your telegram messages via this API.
TELEGRAM_API_URL=api.telegram.org

# A key size of 2048 bits is great for security but the SoC might run out of memory, if that happens try with 1024.
PRIVATE_KEY_SIZE=2048

# Country code must be two letters.
COUNTRY_CODE=XX

STATE=STATE_OR_PROVINCE
CITY=CITY_NAME
ORG=ORGANIZATION_NAME

# The domain name the SoC will display in the local network.
DOMAIN_NAME=esp8266.local

# The lifespan in days for the Soc's certificate.
CERT_LIFESPAN_DAYS=365
```

The .env file should reside at the same directory level as the envVariablesCreator.py script. After its creation, your file structure should resemble the following:

```
CredentialUtils/
Esp8266Sketch/
.env
.gitignore
envVariablesCreator.py
README.md
requirements.txt
WOL_Diagram.svg
```

After executing the 'envVariablesCreator.py' script, each user will receive a randomly generated four-digit PIN as their password. This PIN will be displayed in the terminal alongside their username, so it's important to save this information. Additionally, QR codes will be generated for each user. These QR codes can be scanned using your preferred TOTP authentication app (such as Google Authenticator or Microsoft Authenticator) to enable one-time passwords.

Furthermore, a new file named 'envVariables.h' will be created within the 'Esp8266Sketch' folder:

```
Esp8266Sketch/
├── utils/
├── views/
├── envVariables.h
└── Esp8266Sketch.ino
```

NOTE: Remember to write down each user's four digit pin, as it will not be retrievable after the terminal closes or gets cleared.

## .Env File Variables

#### WIFI_NAME & WIFI_PASSWORD

These variables hold your WiFi network name and password respectively. These allow the Esp8266 to connect to your WiFi, enabling it to send the magic packets to any device in that network.

NOTE: If the Esp8266 isn't being able to connect to your Wifi, try writing the network name in upper case.

#### ESP8266_STATIC_IP

Makes it so your Esp8266 always has the same ip on your network. This is specially usefull if you're planning to access the web server over the internet via port-forwarding. Alternatively, this can be configured from the router using the SoC's MAC address. If you only want to use the web server on your LAN just set the ip to an address currently not used in your network, or disable this feature altogether.

#### ROUTER_LOCAL_GATEWAY & SUBNET

To avoid issues when communicating to the internet, the Esp8266 needs to know your routers default local gateway and subnet. Depending on your OS, you can look for tutorials online on how to get them.

#### IP_SITE_URL

The url from which the Esp8266 will attempt to retrieve the public IP from. Since the Esp8266 doesn't support IPv6, your'll require to have a public IPv4 address.

#### USER_SESSIONS

This array holds each of the users' session properties in a JSON structure. Each user session should adhere to the structure '{"username": "USERNAME", "timeout": TIME_IN_SECONDS, "totp_label": "TOTP_LABEL", "issuer": "ISSUER_NAME"}' where:

```
username: Specifies the user's name for the session.
timeout: Indicates the maximum duration, in seconds, before the session automatically closes.
totp_label: Represents the label displayed on your TOTP app. Its purpose is to allow multiple labels per issuer.
issuer: Identifies the main name for your one-time code in your chosen TOTP app. It precedes the totp_label in the hierarchy.
```

You can have as many user sessions as you like, limited only by the storage and RAM capabilities of the ESP8266. Alternatively, you can also manually assign each user its four digit pin code, as well as its QR code, but it would require you to modify the 'envVariables.h' file.
To create your users manually, run the 'envVariablesCreator.py' as you normally would, and open the 'envVariables.h' file. Inside of it, you'll see an array of the user sessions that looks as follows:

```
UserSession userSessions[numUSessions] = {
  // Hash is made from the string "admin:admin" (the username is "admin" and the password is "admin" as well)
  { "The Admin", "8da193366e1554c08b2870c50f737b9587c3372b656151c4a96028af26f51334", { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF }, 60},
  // Hash is user:user
  { "The User", "dc05eb46a46f4645f14bff72c8dfe95e0ba1b1d3d72e189ac2c977a44b7dcaf8", { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF }, 60}
};
```

As you can see, each user session is composed of an username, a hash (in order to not save passwords in plain text), an hmac key (for the totp QR code), and a timeout value. From this values, the only ones you shouldn't modify manually are the hash and the hmac key as they are automatically generated. Fortunatelly, you can make use of the utilities to create them both, just create a python script at the same level as the 'envVariablesCreator.py' and paste the following code: 

```
from CredentialUtils import UserSession
# Get the hash from the 'USERNAME:PIN_CODE' string combination (remember, the esp8266 uses a mix of the username and the pin code to create the hash, so your input should look like that).
print(UserSession.generate_sha256_hash("USERNAME:PIN_CODE"))
# Create a new QR code for the user "USERNAME" and print the QR code's hmac key.
print(print(UserSession.create_qr_code("USERNAME", "TOTP_LABEL", "TOTP_ISSUER")))
```

After running this script, a new QR code will be created for the user, with its hmac key and the user's new hash being printed to the terminal. 

#### TELEGRAM_BOT_TOKEN,  TELEGRAM_CHAT_ID, & TELEGRAM_API_URL

These variables store information regarding your telegram bot. This is usefull if you're planning to access your SoC's website from outside the LAN since you'll need the public IP from your router. This code makes it so that the Esp8266 sends you the public IP upon startup and keeps looking for changes in the public IP every hour (you can change the interval on the wifi_utils.h file), re-sends it if it changed, all of this via your telegram bot.

```
TELEGRAM_BOT_TOKEN: When creating a telegram bot using the 'BotFather' it will throw you a token to access the HTTP API; this is your bot token.
TELEGRAM_CHAT_ID: This is your telegram user id, since the bot will be sending messages, in behalf of the Esp8266 module, to you.
TELEGRAM_API_URL: This is the link to telegram's API. It is needed since the 'envVariablesCreator.py' retrieves its certificate so the SoC can verify that the identity of the API, avoiding man-in-the-middle attacks.
```

#### CERTIFICATE & PRIVATE KEY Variables

In order to use HTTPS secure connections, the SoC webserver needs to use an SSL certificate and a private RSA key (which will be generated by the 'envVariablesCreator.py' script). The SSL certificate will be self-signed so you don't need to buy one (you could buy one if you really want to), the only issue is that when you connect to the SoC's website the connection will be marked as insecure and you'll likely get a warning in your browser (which you can ignore).

```
PRIVATE_KEY_SIZE: The size for the private key in bits. A key size of 2048 bits is great for security but the SoC might run out of memory, if that happens try with 1024.
COUNTRY_CODE: Country code of two letters
STATE: The country's state the certificate will show.
CITY: The state's city the certificate will show
ORG: The organization the certificate will show
DOMAIN_NAME: The domain name for the SoC's website (you should probably use the default esp8266.local)
CERT_LIFESPAN_DAYS: The number of days before the certificate and private key expire.
```
